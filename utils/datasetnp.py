from torch.utils.data import Dataset, DataLoader
import pandas as pd
import numpy as np
import torch
import os


class DatasetDWT(Dataset):
    def __init__(self, file_csv, file_root, file_root_ori, **kwargs):
        self.df = pd.read_csv(file_csv)
        self.file_root = file_root
        self.file_root_ori = file_root_ori

        # Pseudo GT generated by traditional PRNU algorithm with 40 RAW images per camera as described in
        # Section 2.1 of paper.
        path_reg = '/path/to/pseudo/GT'
        crop_length = 256

        name_reg = sorted(os.listdir(path_reg))
        list_reg = [os.path.join(path_reg, k) for k in name_reg]
        print('reg num:', len(list_reg))

        self.prnu_list = []
        for p in list_reg:
            data = self.cut_center(np.load(p), (crop_length, crop_length))
            self.prnu_list.append(torch.from_numpy(data).unsqueeze(0))

    def __getitem__(self, idx):
        imgs = []
        path_list = self.df[self.df['sample_id'] == idx]
        for p in path_list['path']:
            temp = np.load(p.replace(self.file_root_ori, self.file_root) + '.npy')
            imgs.append(np.expand_dims(temp, 0))
        set_id = path_list['set_id'].to_list()[0]

        im_tensor = torch.from_numpy(np.concatenate(imgs, axis=0)) / 255.
        label = torch.tensor(set_id)

        expo = torch.tensor(eval(path_list['exposure'].to_list()[0]))
        iso = torch.tensor(path_list['iso'].to_list()[0])

        return im_tensor.float(), self.prnu_list[label].float(), label.float(), expo.float(), iso.float()

    def __len__(self):
        return len(self.df['sample_id'].unique())

    def load_single(self, p):
        return np.load(p.replace(self.file_root_ori, self.file_root) + '.npy')

    def cut_center(self, img, sizes):
        array = np.copy(img)
        if array.ndim == 3 and len(sizes) == 2:
            sizes = (*sizes, array.shape[2])
        elif (array.ndim != len(sizes)):
            raise ValueError(f"array.ndim {array.ndim} are not equal to sizes {len(sizes)}")
        for axis in range(array.ndim):
            axis_target_size = sizes[axis]
            axis_original_size = array.shape[axis]
            if axis_target_size > axis_original_size:
                raise ValueError(
                    'Can\'t have target size {} for axis {} with original size {}'.format(axis_target_size, axis,
                                                                                          axis_original_size))
            else:
                axis_start_idx = (axis_original_size - axis_target_size) // 2
                axis_end_idx = axis_start_idx + axis_target_size
                array = np.take(array, np.arange(axis_start_idx, axis_end_idx), axis)
        return array
